5		
23		
12		
564
435
3
234		12
1		23
2		5
A		B

etape 1
	tout push dans B sauf 3 elements
	algo 3 sur la pile A

		564
		435
		3
10		12
200		23
500		5
A		B

etape 2
	ft_daron(pilea, int n) // renvoie le nombre le plus proche au dessus
						 // si n > max(pilea) -> return min(pilea)
	564	-> 10
	435 -> 500
	3	-> 10
	12  -> 200
	23	-> 200
	5 	-> 10 

etape 3
	calculerdecoup()
		564
		435
		3
10		12
200		231
201		232
202		233
203		250
204		235
205		236
300		400  // test
500		5
A		B

	enfant		parent		B	A	TOTAL
	564		->	10      = 	0	0	0
	435 	->	500		=	1	1	2
	3		->	10		=	2	0	2
	12  	->	200		=	2	1	3
	23		->	200		=	2	1	3
	5 		->	10 		=	1	0	1
	250		->	300		=	5	2	5

if parent et enfant vont dans la mm direction
	prix = le plus grand des deux
else
	prix = enfant + parent

etape 4

		435
564		3
10		12
200		23
500		5
A		B

recommencer etape 2 tant que b n'est pas vide
 
etape finale
	mettre min(a) tout en haut de la pile
